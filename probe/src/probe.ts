interface Options {
	[k: string]: any;
	key: string | null;
	url: string;
	chunkSize: number;
	debug: boolean;
	throttle: number;
}

interface SelectorRecord {
	files: string[];
	seen: boolean;
	parent: SelectorRecord;
	fcn: CheckerFcn;
	checked: boolean;
}

export interface ProbeApiV1 {
	v: "0.1";
	k: string;
	f: Record<string, string[]>;
}

type CheckerFcn = (selector: string) => boolean;

export class Probe {
	private options: Options = {
		/**
		 * Key generated by bleachcss.com
		 */
		key: null,

		/**
		 * Where the probe are being sent
		 */
		url: "https://www.bleachcss.com/api/v1/probes/",

		/**
		 * How many Selector will be used in each chunk tests
		 */
		chunkSize: 250,

		debug: true,

		/**
		 * How frequently can the Probe check for results?
		 */
		throttle: 200,
	};

	/**
	 * Store the URL of the CSS files we have fetched, usefull to avoid reprocessing the same files
	 */
	private _cssFilesURLs: string[] = [];

	/**
	// Map of all the selectors we have found in the CSS files
	// Use following structure
	// "selector string": {
	//      files: [] -> array of files that contain the selector
	//      seen: true/false                -> indicate if the selector has been already seen
	//      fcn: document.getElementById    -> the method that will be call to detect usage of this selector
	//      parent: object                  -> point to the selector object, used to avoid checking dependent
	//                                          selector of something not in the DOM yet
	// }
	 * @type {Object<string, *>}
	 */
	private _allSelectors: Record<string, SelectorRecord> = {};

	/**
	 * Map of the selector that have not been seend in the DOM yet
	 * @type {Object<string, boolean>}
	 */
	private _unseenSelectors: Record<string, boolean> = {};

	/**
	 * List of selector that have been seen in the DOM but did not got send yet to the server.
	 */
	private _buffer: string[] = [];

	/**
	 * Timestamp of the last call to the function checking which selector are used.
	 * @type {number}
	 */
	private _timeMainLoopCall = 0;

	/**
	 * Timestamp of the AJAX request flushing the buffer
	 * @type {number}
	 */
	private _timeBufferFlushCall = 0;

	/**
	 *
	 */
	private _DOMObserv: MutationObserver | null = null;

	/**
	 * Initialize the probe and start recording usage
	 * @param {Object} userOptions User defined value for the options of the Probe
	 */
	start(userOptions: Options) {
		// Copy over options
		for (var name in userOptions) {
			this.options[name] = userOptions[name];
		}

		if (!this.options.key) {
			throw Error("BleachCSS require an API key");
		}
		this.resume();
	}

	/**
	 * Stop observing DOM manipulation, but keep the state intact.
	 */
	stop() {
		if (!this._DOMObserv) {
			return;
		}
		this._DOMObserv.disconnect();
		this._DOMObserv = null;
	}

	/**
	 * Re-Start listening to DOM manipulation.
	 */
	resume() {
		var self = this;
		if (!self._DOMObserv) {
			return;
		}
		self._DOMObserv = new MutationObserver(function (mutations) {
			self._log("Mutation", mutations);
			self._mainLoop();
		});
		self._DOMObserv.observe(document, { subtree: true, childList: true });
		self._mainLoop();
	}

	private _log(...args: any[]) {
		if (this.options.debug) {
			console.log.apply(console, args);
		}
	}

	/**
	 * Master function controlling the detection of CSS
	 */
	private _mainLoop() {
		var self = this;
		var t1 = new Date().getTime();
		if (t1 - this._timeMainLoopCall < this.options.throttle) {
			return;
		}
		// console.profile("full detection");
		// console.time("full detection");
		this._timeMainLoopCall = t1;

		// New CSS files can be loaded dynamically.
		this._syncSelectors();

		for (var selector in self._allSelectors) {
			self._allSelectors[selector].checked = false;
		}
		this._checkSelectorsByChunk(
			Object.keys(this._unseenSelectors),
			function () {
				// console.profileEnd("full detection");
				// console.timeEnd("full detection");
				var t2 = new Date().getTime();
				var PING_FREQUENCY = 500;
				if (t2 - self._timeBufferFlushCall > PING_FREQUENCY) {
					self._timeBufferFlushCall = t2;
					self._sendBuffer();
				}
			}
		);
	}

	/**
	 * Check
	 */
	private _syncSelectors() {
		var self = this;
		var urls = this._processStyleSheets();
		this._downloadCSSFiles(urls, function (url, text) {
			self._extractSelectors(url, text);
			self._mainLoop();
		});
	}

	/**
	 *
	 */
	public _processStyleSheets(): string[] {
		/** @type {any} */
		var styleSheets = document.styleSheets;
		var urlsToLoad: string[] = [];
		for (var i = 0; i < styleSheets.length; i++) {
			/** @type {CSSStyleSheet} */
			var stylesheet = styleSheets[i];
			var href = stylesheet.href;

			// if we have not processed the file already
			if (
				href &&
				href.substr(0, 4) === "http" &&
				this._cssFilesURLs.indexOf(href) === -1
			) {
				// we find rule, it means we can process them directly
				var rules: CSSRuleList | null = null;

				try {
					// Accessing this prop can trigger an exception
					rules = stylesheet.cssRules;
					if (rules) {
						this._cssFilesURLs.push(href);
						this._processCssRules(href, rules);
					}
				} catch (e) {
					// No op
				}

				// we need to return the url, so the file can be processed
				if (!rules) {
					// urlsToLoad.push(href);
				}
			}
		}
		return urlsToLoad;
	}

	/**
	 *
	 */
	private _processCssRules(fileURL: string, rules: CSSStyleRule[]) {
		for (var i = 0; i < rules.length; i++) {
			var selectorText = rules[i].selectorText;
			if (selectorText) {
				this._addSelector(fileURL, selectorText, true);
			}
		}
	}

	private _extractSelectors(fileURL: string, source: string) {
		if (!source) {
			return;
		}
		// Remove comments
		source = source.replace(new RegExp("(\\/\\*[\\s\\S]*?\\*\\/)", "gi"), "");

		// Remove Keyframe stuff
		var reg = new RegExp(
			"((@(-.*?-)?keyframes [\\s\\S]*?){([\\s\\S]*?}\\s*?)})",
			"gi"
		);
		source = source.replace(reg, "");

		// Handle regular selectors and media query selectors
		// Media Query capture = '((@media [\\s\\S]*?){([\\s\\S]*?}\\s*?)})';
		reg = new RegExp(
			"((\\s*?(?:\\/\\*[\\s\\S]*?\\*\\/)?\\s*?@[media|supports][\\s\\S]*?){([\\s\\S]*?)}\\s*?})|(([\\s\\S]*?){([\\s\\S]*?)})",
			"gi"
		);

		while (true) {
			var arr = reg.exec(source);
			if (arr === null) {
				break;
			}
			var selector = "";
			if (arr[2] === undefined) {
				selector = arr[5].split("\r\n").join("\n").trim();
			} else {
				selector = arr[2].split("\r\n").join("\n").trim();
			}

			// Never have more than a single line break in a row
			selector = selector.replace(/\n+/, "\n");

			//determine the type
			if (
				selector.indexOf("@media") !== -1 ||
				selector.indexOf("@supports") !== -1
			) {
				this._extractSelectors(fileURL, arr[3] + "\n}");
			} else {
				this._addSelector(fileURL, selector, true);
			}
		}
	}

	/**
	 * Create a record of a selector
	 */
	private _addSelector(url: string, text: string, existsInStyleSheet: boolean) {
		var self = this;
		text.split(",").forEach(function (item) {
			var splits = item.split(":");
			var selector = item;
			if (splits[splits.length - 1].indexOf("-child") === -1) {
				selector = splits[0];
			}
			selector = selector.trim();
			if (selector.length) {
				if (selector === "@font-face") {
					return;
				}
				if (!self._allSelectors[selector]) {
					self._allSelectors[selector] = {
						files: [],
						seen: false,
						exists: false,
						checked: false,
						fcn: self._findChecker(selector),
						parent: self._findParentSelector(selector),
					};
				}

				if (existsInStyleSheet) {
					self._allSelectors[selector].exists = true;
					self._unseenSelectors[selector] = true;
				}

				if (url && self._allSelectors[selector].files.indexOf(url) === -1) {
					self._allSelectors[selector].files.push(url);
				}
			}
		});
	}

	/**
	 *
	 */
	private _findParentSelector(selector: string): string | null {
		// This find parent pattern with space seperated selector
		// @TODO extra suport
		// attribute selector => blob[attribute=value]
		// multiple class selector => .red.square
		//      --> sort them?
		//      --> create a popularity sort?

		var splits = selector.split(/\s|\+|~|>/);
		if (splits.length === 1) {
			return null;
		}

		var last = splits.pop();
		var parentSelector = selector
			.substr(0, selector.length - last.length - 1)
			.trim();
		if (["+", "~", ">"].indexOf(parentSelector.slice(-1)) !== -1) {
			parentSelector = parentSelector.slice(0, -1).trim();
		}

		this._addSelector(null, parentSelector, false);
		return parentSelector;
	}

	/**
	 * Find used selectors from the list of unused selector we already have
	 */
	private _checkSelectorsByChunk(selectors: string[], doneCb: () => void) {
		// console.time('detect');
		var ll = selectors.length;
		var limit = ll > this.options.chunkSize ? this.options.chunkSize : ll;

		for (var i = 0; i < limit; i++) {
			this._selectorCheck(selectors.pop());
		}
		// console.timeEnd('detect');

		// Nothing else to process, return
		if (selectors.length === 0) {
			return doneCb();
		}

		// Schedule an other batch of selector to process
		var self = this;
		setTimeout(function () {
			self._checkSelectorsByChunk(selectors, doneCb);
		}, 0);
	}

	/**
	 *
	 */
	private _selectorCheck(selectorText: string): boolean {
		var a = this.__selectorCheck(selectorText);
		this._allSelectors[selectorText].checked = true;
		return a;
	}

	private __selectorCheck(selectorText: string): boolean {
		var item = this._allSelectors[selectorText];
		if (item.checked) {
			return item.seen;
		}

		if (item.seen) {
			return true;
		}

		if (item.parent) {
			// If we have not seen the parent, there is no way we can find the children
			if (!this._selectorCheck(item.parent)) {
				return false;
			}
		}

		try {
			if (item.fcn(selectorText)) {
				if (item.exists) {
					delete this._unseenSelectors[selectorText];
					this._buffer.push(selectorText);
				}
				item.seen = true;
				return true;
			}
		} catch (e) {
			console.warn(e);
			console.warn(
				"BleachCSS Probe encounter an error. Please file a bug https://github.com/genintho/bleachcss-probe/issues/new"
			);
		}

		return false;
	}

	/**
	 * Identify which function need to be used to check the existence of the element
	 */
	private _findChecker(selector: string): CheckerFcn {
		if (/^#[^\s]+$/.test(selector)) {
			return this._fcnCheckByID;
		}

		if (/^\.[^\s]+$/.test(selector)) {
			return this._fcnCheckClass;
		}
		// @TODO get element by tag name
		return this._fcnCheckFallback;
	}

	/**
	 * Detect if the ID is defined in the DOM
	 * @param {string} selector
	 * @return {boolean}
	 */
	private _fcnCheckByID(selector: string): boolean {
		if (document.getElementById(selector.substr(1))) {
			return true;
		}
		return false;
	}

	/**
	 * Detect if a class is defined in the DOM
	 * @param {string} selector
	 * @return {boolean}
	 */
	_fcnCheckClass(selector: string): boolean {
		if (document.getElementsByClassName(selector.substr(1)).length) {
			return true;
		}
		return false;
	}

	/**
	 * Detect if 1 DOM element is matching the selector
	 * @param {string} selector
	 * @return {boolean}
	 */
	private _fcnCheckFallback(selector: string): boolean {
		if (document.querySelector(selector)) {
			return true;
		}
		return false;
	}

	/**
	 * Make a GET request to try to download the CSS files
	 */
	private _downloadCSSFiles(
		stylesheetURLs: string[],
		callback: (url: string, txt: string) => void
	) {
		var self = this;
		stylesheetURLs.forEach(function (url) {
			// Already fetched
			if (self._cssFilesURLs.indexOf(url) !== -1) {
				return;
			}

			// dont fetch data url
			var dataURl = "data:text/css";
			if (url.substr(0, dataURl.length) === dataURl) {
				return;
			}

			self._cssFilesURLs.push(url);
			var ajax = new XMLHttpRequest();
			ajax.onreadystatechange = function () {
				if (ajax.readyState === 4 && ajax.status === 200) {
					callback(url, ajax.responseText);
				}
			};

			ajax.open("GET", url, true);
			ajax.send(null);
		});
	}

	/**
	 * Send the results to the backend
	 */
	private _sendBuffer() {
		var self = this;
		var cloneBuffer = [].concat(this._buffer);
		// Reset the buffer so we do not send the same thing again and again
		this._buffer = [];
		this._log("buffer", cloneBuffer.length, cloneBuffer);
		if (cloneBuffer.length === 0) {
			return;
		}
		var data: ProbeApiV1 = {
			v: "0.1", // API_VERSION. Use by the server to know what to do with the payload
			k: this.options.key as string,
			f: {},
		};
		cloneBuffer.forEach(function (selector) {
			var files = self._allSelectors[selector].files;
			files.forEach(function (file) {
				if (!data.f[file]) {
					data.f[file] = [];
				}
				data.f[file].push(selector);
			});
		});

		var httpRequest = new XMLHttpRequest();
		httpRequest.open("POST", self.options.url);
		httpRequest.send(JSON.stringify(data));
	}
}
